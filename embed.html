<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Contribution Tree</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
            overflow: hidden;
        }
        
        #tree3d {
            width: 100vw;
            height: 100vh;
        }
        
        .tree-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255,255,255,0.9);
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            font-size: 14px;
            max-width: 250px;
        }
        
        .tree-info h3 {
            margin: 0 0 10px 0;
            color: #4CAF50;
            font-size: 16px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }
        
        .stat-label {
            color: #666;
        }
        
        .stat-value {
            font-weight: bold;
            color: #4CAF50;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            text-align: center;
        }
        
        .loading::after {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
            margin-left: 10px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .github-link {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            text-decoration: none;
            font-size: 12px;
            opacity: 0.8;
            transition: opacity 0.3s;
        }
        
        .github-link:hover {
            opacity: 1;
        }
        
        @media (max-width: 768px) {
            .tree-info {
                top: 10px;
                left: 10px;
                right: 10px;
                max-width: none;
                padding: 10px 15px;
                font-size: 12px;
            }
            
            .github-link {
                bottom: 10px;
                right: 10px;
                padding: 6px 10px;
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <div id="tree3d"></div>
    
    <div class="tree-info" id="treeInfo" style="display: none;">
        <h3 id="treeTitle">ðŸŒ± Contribution Tree</h3>
        <div class="stat-row">
            <span class="stat-label">Contributions:</span>
            <span class="stat-value" id="contributions">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Tree Level:</span>
            <span class="stat-value" id="treeLevel">Seed</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Lines of Code:</span>
            <span class="stat-value" id="linesOfCode">0</span>
        </div>
    </div>
    
    <div class="loading" id="loading">
        Growing your contribution tree...
    </div>
    
    <a href="#" class="github-link" id="githubLink" style="display: none;">
        View Full Interactive Tree
    </a>

    <script>
        class EmbedContributionTree {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.treeGroup = null;
                this.animationId = null;
                
                this.username = '';
                this.contributions = 0;
                this.linesOfCode = 0;
                this.treeLevel = 'Seed';
                
                this.branches = [];
                this.leaves = [];
                this.trunk = null;
                
                this.init();
                this.loadFromURL();
            }
            
            init() {
                const container = document.getElementById('tree3d');
                
                // Scene setup
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);
                
                // Camera setup
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(5, 8, 12);
                this.camera.lookAt(0, 3, 0);
                
                // Renderer setup
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                container.appendChild(this.renderer.domElement);
                
                // Lighting
                this.setupLighting();
                
                // Ground
                this.setupGround();
                
                // Tree group
                this.treeGroup = new THREE.Group();
                this.scene.add(this.treeGroup);
                
                // Start animation loop
                this.animate();
                
                // Handle resize
                window.addEventListener('resize', () => this.onWindowResize());
            }
            
            setupLighting() {
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 20, 5);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);
            }
            
            setupGround() {
                const groundGeometry = new THREE.PlaneGeometry(30, 30);
                const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x8FBC8F });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);
            }
            
            async loadFromURL() {
                const urlParams = new URLSearchParams(window.location.search);
                const username = urlParams.get('user') || urlParams.get('username');
                
                if (!username) {
                    this.showError('No username provided');
                    return;
                }
                
                this.username = username;
                
                try {
                    await this.fetchGitHubData(username);
                    this.hideLoading();
                    this.showTreeInfo();
                    this.growTree();
                } catch (error) {
                    console.error('Error:', error);
                    // Use demo data
                    this.contributions = Math.floor(Math.random() * 800) + 100;
                    this.linesOfCode = this.contributions * 50;
                    this.updateTreeLevel();
                    this.hideLoading();
                    this.showTreeInfo();
                    this.growTree();
                }
            }
            
            async fetchGitHubData(username) {
                try {
                    console.log(`Fetching real GitHub data for ${username}...`);
                    
                    // Fetch user data and repositories from real GitHub API
                    const [userData, reposData] = await Promise.all([
                        this.fetchGitHubUser(username),
                        this.fetchGitHubRepos(username)
                    ]);
                    
                    // Calculate real contribution statistics
                    const stats = this.calculateContributionStats(userData, reposData);
                    
                    this.contributions = stats.contributions;
                    this.linesOfCode = stats.linesOfCode;
                    this.updateTreeLevel();
                    
                    console.log('Real GitHub data loaded:', stats);
                    
                } catch (error) {
                    console.error('Error fetching GitHub data:', error.message);
                    // Fallback values if API fails
                    this.contributions = 150;
                    this.linesOfCode = 7500;
                    this.updateTreeLevel();
                }
            }
            
            async fetchGitHubUser(username) {
                const response = await fetch(`https://api.github.com/users/${username}`, {
                    headers: {
                        'Accept': 'application/vnd.github.v3+json',
                        'User-Agent': 'GitHub-Tree-Embed'
                    }
                });
                
                if (!response.ok) {
                    if (response.status === 404) {
                        throw new Error(`User "${username}" not found`);
                    } else if (response.status === 403) {
                        throw new Error('GitHub API rate limit exceeded');
                    } else {
                        throw new Error(`GitHub API error: ${response.status}`);
                    }
                }
                
                return await response.json();
            }
            
            async fetchGitHubRepos(username) {
                try {
                    let allRepos = [];
                    let page = 1;
                    let hasMore = true;
                    
                    // Fetch up to 3 pages for embed version to be faster
                    while (hasMore && page <= 3) {
                        const response = await fetch(
                            `https://api.github.com/users/${username}/repos?per_page=100&page=${page}&sort=updated&direction=desc`,
                            {
                                headers: {
                                    'Accept': 'application/vnd.github.v3+json',
                                    'User-Agent': 'GitHub-Tree-Embed'
                                }
                            }
                        );
                        
                        if (!response.ok) {
                            console.warn(`Error fetching repos page ${page}:`, response.status);
                            break;
                        }
                        
                        const repos = await response.json();
                        allRepos = allRepos.concat(repos);
                        hasMore = repos.length === 100;
                        page++;
                        
                        // Small delay for API respect
                        if (hasMore) {
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                    }
                    
                    return allRepos;
                    
                } catch (error) {
                    console.warn('Error fetching repositories:', error.message);
                    return [];
                }
            }
            
            calculateContributionStats(userData, reposData) {
                const accountCreated = new Date(userData.created_at);
                const accountAgeYears = (new Date() - accountCreated) / (1000 * 60 * 60 * 24 * 365);
                
                // Filter out forked repositories
                const originalRepos = reposData.filter(repo => !repo.fork);
                
                let totalContributions = 0;
                let estimatedLinesOfCode = 0;
                
                // Base contributions from account metrics
                totalContributions += userData.public_repos * 8;
                totalContributions += Math.min(userData.followers * 3, 300);
                
                // Process repositories
                originalRepos.forEach(repo => {
                    const repoSize = repo.size || 0;
                    const stars = repo.stargazers_count || 0;
                    const forks = repo.forks_count || 0;
                    
                    // Lines of code estimation
                    estimatedLinesOfCode += repoSize * 25;
                    
                    // Contribution calculation
                    let repoContribution = Math.min(repoSize * 0.08, 40);
                    repoContribution += Math.min(stars * 4, 120);
                    repoContribution += Math.min(forks * 6, 60);
                    
                    // Recent activity bonus
                    const lastUpdate = new Date(repo.updated_at);
                    const daysSinceUpdate = (new Date() - lastUpdate) / (1000 * 60 * 60 * 24);
                    
                    if (daysSinceUpdate < 30) repoContribution *= 1.4;
                    else if (daysSinceUpdate < 90) repoContribution *= 1.1;
                    
                    totalContributions += repoContribution;
                });
                
                // Account age factor
                const ageMultiplier = Math.min(1 + (accountAgeYears * 0.4), 2.5);
                totalContributions *= ageMultiplier;
                
                // Ensure minimum values for active accounts
                if (originalRepos.length > 0) {
                    totalContributions = Math.max(totalContributions, 75);
                    estimatedLinesOfCode = Math.max(estimatedLinesOfCode, 1500);
                }
                
                return {
                    contributions: Math.floor(totalContributions),
                    linesOfCode: Math.floor(estimatedLinesOfCode)
                };
            }
            
            updateTreeLevel() {
                if (this.contributions <= 50) {
                    this.treeLevel = 'Sprout';
                } else if (this.contributions <= 200) {
                    this.treeLevel = 'Sapling';
                } else if (this.contributions <= 500) {
                    this.treeLevel = 'Mature Tree';
                } else {
                    this.treeLevel = 'Ancient Tree';
                }
            }
            
            hideLoading() {
                document.getElementById('loading').style.display = 'none';
            }
            
            showTreeInfo() {
                document.getElementById('treeTitle').textContent = `ðŸŒ± ${this.username}'s Tree`;
                document.getElementById('contributions').textContent = this.contributions;
                document.getElementById('treeLevel').textContent = this.treeLevel;
                document.getElementById('linesOfCode').textContent = this.linesOfCode.toLocaleString();
                document.getElementById('treeInfo').style.display = 'block';
                
                // Update GitHub link
                const githubLink = document.getElementById('githubLink');
                const baseUrl = window.location.origin + window.location.pathname.replace('embed.html', 'index.html');
                githubLink.href = `${baseUrl}?user=${this.username}`;
                githubLink.style.display = 'block';
            }
            
            showError(message) {
                document.getElementById('loading').textContent = `Error: ${message}`;
            }
            
            growTree() {
                this.generate3DTree();
                this.animate3DGrowth();
            }
            
            generate3DTree() {
                const trunkHeight = Math.min(6, 1.5 + (this.contributions * 0.008));
                const trunkRadius = Math.max(0.15, this.contributions / 800);
                
                this.createTrunk(trunkHeight, trunkRadius);
                this.createBranches(trunkHeight, trunkRadius);
                this.createLeaves();
            }
            
            createTrunk(height, radius) {
                const trunkGeometry = new THREE.CylinderGeometry(radius, radius * 1.3, height, 8);
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                
                this.trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                this.trunk.position.y = height / 2;
                this.trunk.castShadow = true;
                this.trunk.scale.y = 0;
                
                this.treeGroup.add(this.trunk);
            }
            
            createBranches(trunkHeight, trunkRadius) {
                const numBranches = Math.min(15, Math.floor(this.contributions / 30) + 2);
                
                for (let i = 0; i < numBranches; i++) {
                    const branchLevel = Math.floor(i / 3);
                    const branchHeight = trunkHeight * (0.7 - branchLevel * 0.15);
                    const branchLength = trunkHeight * (0.5 - branchLevel * 0.1);
                    const branchRadius = trunkRadius * (0.6 - branchLevel * 0.15);
                    
                    const angle = (i * Math.PI * 2) / (numBranches / (branchLevel + 1));
                    const tilt = Math.PI / 8 + (branchLevel * Math.PI / 16);
                    
                    const branchGeometry = new THREE.CylinderGeometry(
                        branchRadius * 0.4, 
                        branchRadius, 
                        branchLength, 
                        6
                    );
                    const branchMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
                    
                    const branch = new THREE.Mesh(branchGeometry, branchMaterial);
                    
                    branch.position.y = branchHeight;
                    branch.position.x = Math.cos(angle) * (trunkRadius + branchLength / 3);
                    branch.position.z = Math.sin(angle) * (trunkRadius + branchLength / 3);
                    
                    branch.rotation.z = Math.cos(angle) * tilt;
                    branch.rotation.x = Math.sin(angle) * tilt;
                    
                    branch.castShadow = true;
                    branch.scale.y = 0;
                    
                    this.branches.push(branch);
                    this.treeGroup.add(branch);
                }
            }
            
            createLeaves() {
                const leafCount = Math.min(150, this.contributions / 4);
                
                for (let i = 0; i < leafCount; i++) {
                    const leafGeometry = new THREE.SphereGeometry(0.08, 6, 4);
                    const leafColor = this.getLeafColor();
                    const leafMaterial = new THREE.MeshLambertMaterial({ color: leafColor });
                    
                    const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                    
                    const radius = 1.5 + Math.random() * 3;
                    const height = 2 + Math.random() * 4;
                    const angle = Math.random() * Math.PI * 2;
                    
                    leaf.position.x = Math.cos(angle) * radius;
                    leaf.position.z = Math.sin(angle) * radius;
                    leaf.position.y = height;
                    
                    leaf.scale.setScalar(0.7 + Math.random() * 0.6);
                    leaf.visible = false;
                    
                    this.leaves.push(leaf);
                    this.treeGroup.add(leaf);
                }
            }
            
            getLeafColor() {
                const colors = [0x4CAF50, 0x8BC34A, 0xCDDC39, 0xFFC107];
                const season = Math.floor(this.contributions / 150) % colors.length;
                return colors[season];
            }
            
            animate3DGrowth() {
                let progress = 0;
                const duration = 2500;
                const startTime = Date.now();
                
                const animateGrowth = () => {
                    const elapsed = Date.now() - startTime;
                    progress = Math.min(elapsed / duration, 1);
                    
                    // Grow trunk
                    if (this.trunk) {
                        this.trunk.scale.y = this.easeOutCubic(progress);
                    }
                    
                    // Grow branches
                    this.branches.forEach((branch, index) => {
                        const branchDelay = index * 80;
                        const branchProgress = Math.max(0, (elapsed - branchDelay) / (duration - branchDelay));
                        branch.scale.y = this.easeOutCubic(branchProgress);
                    });
                    
                    // Show leaves
                    if (progress > 0.5) {
                        const leafProgress = (progress - 0.5) / 0.5;
                        this.leaves.forEach((leaf, index) => {
                            if (index < this.leaves.length * leafProgress) {
                                leaf.visible = true;
                                const scale = this.easeOutBounce(leafProgress);
                                leaf.scale.setScalar((0.7 + Math.random() * 0.6) * scale);
                            }
                        });
                    }
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateGrowth);
                    }
                };
                
                animateGrowth();
            }
            
            easeOutCubic(t) {
                return 1 - Math.pow(1 - t, 3);
            }
            
            easeOutBounce(t) {
                const n1 = 7.5625;
                const d1 = 2.75;
                
                if (t < 1 / d1) {
                    return n1 * t * t;
                } else if (t < 2 / d1) {
                    return n1 * (t -= 1.5 / d1) * t + 0.75;
                } else if (t < 2.5 / d1) {
                    return n1 * (t -= 2.25 / d1) * t + 0.9375;
                } else {
                    return n1 * (t -= 2.625 / d1) * t + 0.984375;
                }
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Auto-rotate
                if (this.treeGroup) {
                    this.treeGroup.rotation.y += 0.003;
                }
                
                this.renderer.render(this.scene, this.camera);
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            new EmbedContributionTree();
        });
    </script>
</body>
</html>
